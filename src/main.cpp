#include "IndexProcessor.h"
#include "SearchProcessor.h"
#include "optionparser.h"

#include <iostream>

#include <string>
#include <vector>

using namespace std;

struct Arg : public option::Arg
{
  static option::ArgStatus NonEmpty (const option::Option& option, bool message);
};

enum programOptions {UNKNOWN, HELP, PATTERNFILE, COUNT};

const option::Descriptor usage[] =
  {
    {UNKNOWN, 0, "" , "", Arg::None, "USAGE: findpat2 MODE [OPTIONS] PARAM1 ... PARAMN" },
    {UNKNOWN, 0, "" , "", Arg::None, "This program has two execution modes: INDEX and SEARCH\n"
                                        "MODE is either 'index' or 'search'. Each mode requires a specific list of parameters " 
                                        "(PARAM1, ..., PARAMN) and options (OPTIONS), described as follows:\n" },
    {UNKNOWN, 0, "" , "", Arg::None, "INDEX USAGE: findpat2 index [OPTIONS] TEXTFILE" },
    {UNKNOWN, 0, "" , "", Arg::None, "Produces an index file for TEXTFILE, allowing subsequent pattern searches in TEXTFILE by using SEARCH mode\n"
                                        "The index file is named as TEXTFILE_BASENAME.idx. For example," 
                                        "\"findpat2 index textfile.txt\" produces a file named \"textfile.idx\"\n\n"
                                        "Options:"},
    {HELP, 0, "h" , "help", Arg::None, "  -h, --help  \tPrint usage and exit" },
    {UNKNOWN, 0, "",  "", Arg::None, "\nExamples:\n"
                                             "  findpat2 index textfile1.txt\n"
                                             "  findpat2 index textfile2.txt\n" },
    {UNKNOWN, 0, "" , "", Arg::None, "SEARCH USAGE: findpat2 search [OPTIONS] PATTERN INDEXFILE" },
    {UNKNOWN, 0, "" , "", Arg::None, "Search for PATTERN in text indexed by INDEXFILE, which must be a .idx file generated by this program in INDEX mode\n"
                                        "If --pattern option is set, a list of patterns will be used instead of PATTERN\n\n"
                                        "Options:"},
    {HELP, 0, "h" , "help", Arg::None, "  -h, --help  \tPrint usage and exit" },
    {PATTERNFILE, 0, "p", "pattern", Arg::NonEmpty, "  -p, --pattern  \tSpecify a file with patterns to be searched, one per line," 
                                                                          " instead of using PATTERN" },
    {COUNT, 0, "c", "count", Arg::None, "  -c, --count  \tInstead of printing lines of the text indexed by INDEXFILE in which the patterns occur,"
                                                             " the total count of occurrences will be shown" },
    {UNKNOWN, 0, "",  "", Arg::None, "\nExamples:\n"
                                             "  findpat2 search ababc textfile1.idx\n"
                                             "  findpat2 search -c ababc textfile2.idx\n"
                                             "  findpat2 search -c -p patternfile.txt textfile1.idx\n" },
    {0, 0, 0, 0, 0, 0}
 };

int main(int argc, char** argv) {

  string mode; // execution mode: index or search

  // Optional parameters
  string patternFile; // search
  bool count; // search

  // Required parameters (positional options)
  string textFile; // index
  string pattern; // search
  string indexFile; // search

  // Skip program name
  if (argc > 0) {
    argc -= 1;
    argv += 1;
  }

  // Get and check execution mode
  if (argc > 0) {
    mode = argv[0];

    if ((mode != "index") && (mode != "search")) { // invalid mode option
      if ((mode != "-h") && (mode != "--help")) { // cheking if it is the help option
        cerr << "Invalid execution mode. You have to specify it either as search or index. Try 'findpat2 --help' for more information." << endl;

        return 1;
      }
    }
    else {
      // skip it from parsing
      argc -= 1;
      argv += 1;
    }
  }

  // Initializing option parser structures
  option::Stats  stats(usage, argc, argv);
  option::Option* options = new option::Option[stats.options_max];
  option::Option* buffer = new option::Option[stats.buffer_max];
  option::Parser parse(usage, argc, argv, options, buffer);

  // Error in option parsing
  if (parse.error()){
    return 1;
  }

  // Print usage table if help option was set or no options at all
  if (options[HELP] || argc == 0) {
    option::printUsage(cout, usage);

    return 0;
  }

  // Pattern file option
  if (options[PATTERNFILE]) {
    patternFile = options[PATTERNFILE].last()->arg;
  }

  // Count option
  count = options[COUNT];

  // Positional options (required parameters)
  int positionalOptionsCount = parse.nonOptionsCount();

  if (mode == "index") { // Index mode
    if (positionalOptionsCount == 1) {
      textFile = parse.nonOption(0);
    }
    else {
      cerr << "In index mode, you have to specity a text file to be indexed. Try 'findpat2 --help' for more information." << endl;

      return 1;
    }

    IndexProcessor::processParameters(textFile);
  }
  else { // Search mode
    if (options[PATTERNFILE]) {
      if (positionalOptionsCount == 1) {
        indexFile = parse.nonOption(0);
      }
      else {
        cerr << "In search mode, you have to specity a pattern (or a patternfile) and a index file. Try 'findpat2 --help' for more information." << endl;

        return 1;
      }
    }
    else {
      if (positionalOptionsCount == 2) {
        pattern = parse.nonOption(0);
        indexFile = parse.nonOption(1);
      }
      else {
        cerr << "In search mode, you have to specity a pattern (or a patternfile) and a index file. Try 'findpat2 --help' for more information." << endl;

        return 1;
      }
    }

    SearchProcessor::processParameters(patternFile, count, pattern, indexFile);
  }

  // Unknown options
  for (option::Option* option = options[UNKNOWN]; option; option = option->next()) {
    cout << "Unknown option: " << option->name << endl;
  }

  return 0;
}

// Checking logic for non-empty argument
option::ArgStatus Arg::NonEmpty(const option::Option& option, bool message) {

  if (option.arg != 0 && option.arg[0] != 0) {
    return option::ARG_OK;
  }

  if (message) {
    (cerr << "Option ").write(option.name, option.namelen) << " requires a non-empty argument" << endl;
  }

  return option::ARG_ILLEGAL;
}